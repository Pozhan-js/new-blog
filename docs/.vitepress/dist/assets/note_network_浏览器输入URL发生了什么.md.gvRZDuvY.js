import{_ as e,c as o,o as i,R as t}from"./chunks/framework.e3u47HJq.js";const g=JSON.parse('{"title":"浏览器输入 URL 发生了什么","description":"","frontmatter":{"category":"network","cover":"https://cdn.pixabay.com/photo/2023/10/30/05/19/sunflowers-8351807_640.jpg"},"headers":[],"relativePath":"note/network/浏览器输入URL发生了什么.md","filePath":"note/network/浏览器输入URL发生了什么.md"}'),l={name:"note/network/浏览器输入URL发生了什么.md"},a=t('<h1 id="浏览器输入-url-发生了什么" tabindex="-1">浏览器输入 URL 发生了什么 <a class="header-anchor" href="#浏览器输入-url-发生了什么" aria-label="Permalink to &quot;浏览器输入 URL 发生了什么&quot;">​</a></h1><h2 id="dns-查询" tabindex="-1">DNS 查询 <a class="header-anchor" href="#dns-查询" aria-label="Permalink to &quot;DNS 查询&quot;">​</a></h2><p>DNS 查询顺序如下，如果其中一部成功则直接跳到建立链接部分</p><ol><li>浏览器自身 DNS</li><li>操作系统 DNS</li><li>本地 host 文件</li><li>向域名服务器发送请求</li></ol><p><img src="http://tuchuang.niubin.site/image/network-10.png" alt=""></p><p>向域名服务器发送请求，请求规则如下：</p><ol><li>根域名服务器</li><li>顶级域名服务器</li><li>权威域名服务器</li></ol><p><img src="http://tuchuang.niubin.site/image/network-11.png" alt=""></p><p>DNS 解析之后获取到 ip，有了 ip 发送网络请求，进入 OSI 七层网络模型，其中传输层发起三次握手，发送 http 请求</p><p>我们在发送 post 请求时有时会发现有两个请求，一个是 options 请求，第二个是我们真正的请求，那 options 请求是什么呢？ options 请求会有两种情况出现：</p><ol><li>遇到跨域的时候，浏览器会发送一个 options 请求做一个预检，看能不能通讯</li><li>自定义请求头的时候也会触发 options 请求</li></ol><p><img src="http://tuchuang.niubin.site/image/network-12.png" alt=""></p><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h2><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h3><p>强缓存指的是让浏览器强制缓存服务器端提供的资源</p><p>缓存的资源存放的位置一般有两种：</p><ol><li><code>from disk cache</code> 硬盘缓存</li><li><code>from memory cache</code> 内存缓存</li></ol><p><img src="http://tuchuang.niubin.site/image/network-13.png" alt=""></p><blockquote><p>✨ 当 Cache-Control 和 Expires 同时存在的时候哪个优先级更高呢？</p></blockquote><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><ul><li>Last-Modified: Sat, 09 Apr 2023 20:11:23 GMT(最后被修改的时间)</li><li>If-Modified-Since: Sat, 09 Apr 2023 20:11:23 GMT</li><li>ETag: &quot;aaaaasssdasddasdsd&quot;</li><li>If-None-Match: &quot;aaaaaaaaaaaaaaaa&quot;</li></ul><p>当服务端发现资源最后修改时间和 <code>If-Modified-Since</code> 值相等，代表资源从该时间后再未改变过。服务端于是返回 <code>304(Not Modified)</code> 状态码，表示资源没有改变，并且响应体为空。浏览器拿到后，就知道原本可能过期的缓存其实还可以继续使用。如果资源改变了，就会返回 200，且响应体带上最新资源。 Etag 的值没有规定一般是文件 hash，你也可以设置版本号之类的去对比</p><blockquote><p>✨ 当 Last-Modified 和 ETag 同时存在的时候哪个优先级更高呢？</p></blockquote><p>到这里请求完就要完成 TCP 的四次挥手了，当完成之后我们拿到 html 文件要如何渲染呢？</p><h2 id="html-渲染" tabindex="-1">HTML 渲染 <a class="header-anchor" href="#html-渲染" aria-label="Permalink to &quot;HTML 渲染&quot;">​</a></h2><p>html 渲染第一步就是绘制 DOM 树</p><p>HTML 解析器将超文本和标签解析为 <code>DOM</code> 树，从上往下进行 <code>AST</code> 抽象语法树一行一行解析我们的 DOM，然后绘制成一个抽象语法树</p><p><img src="http://tuchuang.niubin.site/image/network-14.png" alt=""></p><p>那 CSS 如何解析呢？</p><p>CSS 样式来源主要有 3 种，分别是 通过 link 引用的外部 CSS 文件、style 标签内的 CSS、元素的 style 属性内嵌的 CSS。CSS 渲染引擎会将我们的 CSS 样式表转换为浏览器可以理解的 styleSheets，其样式计算过程主要为:</p><p><img src="http://tuchuang.niubin.site/image/network-15.png" alt=""></p><p>上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引警容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为 CSSOM 的构建过程。</p><p>CSS 绘制的时候会遇到什么呢？</p><ol><li>回流（Reflow）</li></ol><p>当 Render Tree 中部分或者全部元素的尺寸、结构或者某些属性发生改变的时候，浏览器重新渲染部分或者全部文档的过程叫做回流</p><p>导致回流的一些操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口发生改变时</li><li>元素尺寸或者位置发生改变</li><li>元素内容变化（文字数量或者图片大小等）</li><li>元素字体大小发生改变</li><li>添加或者删除可见的 DOM 元素</li><li>激活 CSS 伪类（如 <code>:hover</code>等）</li><li>查询某些属性或者调用某些方法</li></ul><p>一些常用且会导致回流的属性或者方法</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetwidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollwidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedstyle()</code></li><li><code>getBoundingclientRect()</code></li><li><code>scrollTo()</code></li></ul><ol start="2"><li>重绘（Repaint）</li></ol><p>当页面中元素的样式改变并不影响他在文档流中的位置时（如：<code>color</code>、<code>background-color</code>、<code>visibility</code> 等），浏览器将新样式赋予给元素并重新绘制它，这个过程叫做重绘</p><h2 id="javascript-解析" tabindex="-1">JavaScript 解析 <a class="header-anchor" href="#javascript-解析" aria-label="Permalink to &quot;JavaScript 解析&quot;">​</a></h2><p>JavaScript 是浏览器 V8 引擎进行解析的，V8 引擎是由 <code>C++</code> 编写</p><p><img src="http://tuchuang.niubin.site/image/network-16.png" alt=""></p>',44),c=[a];function d(n,p,r,s,h,u){return i(),o("div",null,c)}const m=e(l,[["render",d]]);export{g as __pageData,m as default};
