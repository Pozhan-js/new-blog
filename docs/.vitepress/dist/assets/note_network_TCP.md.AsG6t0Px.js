import{_ as e,c as t,o as a,R as o}from"./chunks/framework.e3u47HJq.js";const k=JSON.parse('{"title":"TCP","description":"","frontmatter":{"category":"network","cover":"https://cdn.pixabay.com/photo/2024/02/21/14/42/flowers-8587835_640.jpg"},"headers":[],"relativePath":"note/network/TCP.md","filePath":"note/network/TCP.md"}'),i={name:"note/network/TCP.md"},n=o('<h1 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h1><h2 id="tcp-连接三次握手" tabindex="-1">TCP 连接三次握手 <a class="header-anchor" href="#tcp-连接三次握手" aria-label="Permalink to &quot;TCP 连接三次握手&quot;">​</a></h2><p><img src="http://tuchuang.niubin.site/image/network-7.png" alt=""></p><p>步骤：</p><ol><li>客户端向服务端发送 SYN 报文，跟服务器进行连接，并且会携带一个序列号 seq</li><li>客户端收到 SYN+seq 字段后，服务端也生成一个 seq 序列号，并且将客户端送过来的 seq+1 作为 ack 携带 ACK 确认号发送给客户端表示之前的 SYN 已经收到了</li><li>客户端收到服务端响应后还会发送一个 ACK 确认序列号有效，并且还会发送 seq（这里的 seq 会通过算法计算处理啊是否与服务端的 ack 值相同），然后将服务端返回的 seq+1 作为新的 ack 发送给服务端，确保一切正常</li></ol><p><img src="http://tuchuang.niubin.site/image/network-8.png" alt=""></p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><p><img src="http://tuchuang.niubin.site/image/network-9.png" alt=""></p><p>步骤：</p><ol><li>断开连接不管是客户端还是服务端都可以主动发起，以客户端为例，客户端先发送 FIN 包生成客户端的 seq 序列号随后进入等待状态，这是第一次挥手</li><li>服务端收到 FIN 包表示自己进入了关闭等待状态，然后向客户端使用 ack 验证，验证成功打上 ACK 标记，并生成服务器的 seq 发送给客户端，这是第二次挥手，在这时，服务端还可以发送未完成的数据</li><li>等待服务端所有任务完成后服务端开始进入最后确认状态，向客户端发送 FIN 包，并验证 ack，使用客户端第一次发送过来的 seq+1 去验证，验证成功打上 ACK 标记，并且生成一个新的序列号 seq 发送给客户端，这是第三次挥手</li><li>客户端收到报文之后进入超时等待 2MSL（1~4 分钟），经过等待后客户端关闭连接，服务端收到信息验证完成 ack 成功后打上 ACK 标记后随之关闭连接</li></ol><blockquote><p>为什么需要超时等待时间? 为了保证服务端收到 ACK 包，假设如果没有 2MSL 的等待时间，ACK 包丢失了，服务端则永远不会断开连接，有了 2MSL，如果一旦发生丢包将会进行超时重传，实现可靠连接</p></blockquote>',11),c=[n];function r(s,l,p,h,_,d){return a(),t("div",null,c)}const m=e(i,[["render",r]]);export{k as __pageData,m as default};
